<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ESP Status Overview - Single Floor</title>
    <style>
      :root {
        font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
        color: #1f2933;
        background-color: #f5f7fa;
      }

      * {
        box-sizing: border-box;
      }

      body {
        min-height: 100vh;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 24px;
      }

      .dashboard {
        width: min(1200px, 100%);
        display: grid;
        grid-template-columns: 2fr 0.9fr;
        gap: 24px;
        background: #fff;
        border-radius: 24px;
        padding: 32px;
        box-shadow: 0 25px 65px rgba(15, 23, 42, 0.12);
      }

      .building-wrapper {
        position: relative;
        border-radius: 32px;
        background: #fff;
        border: 1px solid #e1e5ec;
        padding: 24px;
      }

      .building-grid {
        position: relative;
        width: 100%;
        padding-top: 80%;
        background: radial-gradient(circle at center, #fdfdfd 0%, #f3f6fb 100%);
        border-radius: 24px;
        border: 1px dashed #d7dde8;
        overflow: visible;
        min-height: 500px;
      }

      .esp-point {
        position: absolute;
        width: var(--esp-size, 16px);
        height: var(--esp-size, 16px);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        border: 2px solid rgba(255, 255, 255, 0.6);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.9) 0%, rgba(16, 185, 129, 0.9) 40%, rgba(4, 120, 87, 0.95) 80%);
        box-shadow: 0 0 calc(var(--esp-size, 16px) * 0.9) rgba(16, 185, 129, 0.35);
        z-index: 10;
      }

      .esp-point::after {
        content: "";
        position: absolute;
        inset: -8px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(16, 185, 129, 0.35) 0%, transparent 70%);
        opacity: 0.85;
        transition: opacity 0.2s ease;
      }

      .esp-point[data-status="inactive"] {
        background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.9) 0%, rgba(248, 113, 113, 0.95) 45%, rgba(185, 28, 28, 0.95) 80%);
        box-shadow: 0 0 20px rgba(248, 113, 113, 0.35);
      }

      .esp-point[data-status="inactive"]::after {
        background: radial-gradient(circle, rgba(248, 113, 113, 0.35) 0%, transparent 70%);
      }

      .esp-point:hover,
      .esp-point.selected {
        transform: translate(-50%, -50%) scale(1.15);
      }

      .esp-point.selected::after {
        opacity: 1;
      }

      .esp-point .tooltip {
        position: absolute;
        bottom: 150%;
        left: 50%;
        transform: translateX(-50%);
        background: #111827;
        color: #fff;
        padding: 8px 12px;
        border-radius: 12px;
        font-size: 12px;
        min-width: 120px;
        text-align: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.15s ease, transform 0.15s ease;
        white-space: nowrap;
      }

      .esp-point:hover .tooltip {
        opacity: 1;
        transform: translate(-50%, -4px);
      }

      .distance-label {
        position: absolute;
        transform: translate(-50%, 18px) scale(0.9);
        font-size: 11px;
        color: #0f172a;
        text-align: center;
        pointer-events: none;
        background: rgba(255, 255, 255, 0.95);
        padding: 4px 8px;
        border-radius: 12px;
        border: 1px solid rgba(148, 163, 184, 0.4);
        opacity: 0;
        transition: opacity 0.2s ease, transform 0.2s ease;
        white-space: nowrap;
      }

      .distance-label.visible {
        opacity: 1;
        transform: translate(-50%, 12px) scale(1);
      }

      .info-panel {
        border-radius: 24px;
        border: 1px solid #e1e5ec;
        background: linear-gradient(180deg, #f9fafb 0%, #f1f5f9 100%);
        padding: 24px;
        display: flex;
        flex-direction: column;
        gap: 24px;
      }

      .panel-section h2 {
        margin: 0 0 12px;
        font-size: 20px;
        font-weight: 600;
      }

      .level-switcher {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .level-button {
        border: 1px solid #d7dde8;
        border-radius: 16px;
        padding: 12px 16px;
        background: #fff;
        color: #1f2933;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        transition: border-color 0.2s ease, color 0.2s ease, background 0.2s ease;
      }

      .level-button:hover {
        border-color: #10b981;
      }

      .level-button.active {
        background: #10b981;
        color: #fff;
        border-color: #10b981;
      }

      .legend {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        font-size: 14px;
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }

      .legend-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
      }

      .legend-dot.online {
        background: #10b981;
      }

      .legend-dot.offline {
        background: #ef4444;
      }

      .status-summary {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 12px;
      }

      .summary-card {
        border-radius: 18px;
        padding: 12px 16px;
        background: #fff;
        border: 1px solid #d7dde8;
      }

      .summary-card span {
        font-size: 12px;
        color: #6b7280;
      }

      .summary-card strong {
        display: block;
        font-size: 20px;
        margin-top: 6px;
      }

      .relative-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        font-size: 14px;
      }

      .relative-item {
        display: flex;
        justify-content: space-between;
        background: #fff;
        border: 1px solid #d7dde8;
        border-radius: 14px;
        padding: 8px 12px;
      }

      .relative-item strong {
        font-weight: 600;
        color: #0f172a;
      }

      .relative-placeholder {
        font-size: 14px;
        color: #94a3b8;
        border: 1px dashed #cbd5f5;
        border-radius: 14px;
        padding: 12px;
        text-align: center;
      }

      @media (max-width: 900px) {
        body {
          padding: 12px;
        }

        .dashboard {
          grid-template-columns: 1fr;
          padding: 20px;
        }
      }
    </style>
  </head>
  <body>
    <main class="dashboard">
      <section class="building-wrapper">
        <div class="panel-section">
          <h2>Facility Map</h2>
          <p style="margin: 0; color: #6b7280; font-size: 14px">
            Building floor plan with 50 ESP sensors in vertical rectangular layout (5x10) with natural spacing. Hover a sensor to view its name, status and measured distance.
          </p>
          <div class="legend" style="margin-top: 12px">
            <div class="legend-item">
              <span class="legend-dot online"></span>
              Online
            </div>
            <div class="legend-item">
              <span class="legend-dot offline"></span>
              Offline
            </div>
          </div>
        </div>
        <div id="buildingGrid" class="building-grid"></div>
      </section>
      <aside class="info-panel">
        <div class="panel-section">
          <h2>Overview</h2>
          <div class="status-summary" id="statusSummary"></div>
        </div>
        <div class="panel-section">
          <h2>Relative Distances</h2>
          <div id="relativeDistances" class="relative-list">
            <div class="relative-placeholder">Select a sensor on the map to compare.</div>
          </div>
        </div>
      </aside>
    </main>

    <script>
      // Generate 50 sensors with distance-based positioning
      const cols = 5;
      const rows = 10;
      const totalSensors = cols * rows;
      const sensors = [];
      
      // First, generate sensors with their distance measurements
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const sensorNum = row * cols + col + 1;
          const isActive = Math.random() > 0.25;
          const distance = (Math.random() * 20 + 5).toFixed(1);
          
          sensors.push({
            name: `ESP-${String(sensorNum).padStart(2, '0')}`,
            status: isActive ? "active" : "inactive",
            distance: parseFloat(distance), // Store as number for calculations
            distanceDisplay: `${distance} m`,
            x: 0, // Will be calculated
            y: 0, // Will be calculated
          });
        }
      }
      
      // Distance-based positioning algorithm
      // Use distance measurements to create a grid with natural spacing
      function calculatePositions() {
        const margin = 1; // 1% margin for zoomed out effect
        const availableWidth = 100 - (2 * margin);
        const availableHeight = 100 - (2 * margin);
        
        // Calculate average distance to determine spacing scale
        const avgDistance = sensors.reduce((sum, s) => sum + s.distance, 0) / sensors.length;
        const maxDistance = Math.max(...sensors.map(s => s.distance));
        const minDistance = Math.min(...sensors.map(s => s.distance));
        
        // Use distance values to create irregular grid spacing
        // Map distances to positions: larger distances = more spacing
        const positions = [];
        
        for (let i = 0; i < sensors.length; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;
          
          // Base grid position
          const baseLeft = margin + (col / (cols - 1)) * availableWidth;
          const baseTop = margin + (row / (rows - 1)) * availableHeight;
          
          // Use distance measurement to add variation
          // Normalize distance to 0-1 range
          const distanceNorm = (sensors[i].distance - minDistance) / (maxDistance - minDistance || 1);
          
          // Add offset based on distance (sensors with larger distances spread out more)
          const leftOffset = (Math.random() - 0.5) * 8 + (distanceNorm - 0.5) * 4;
          const topOffset = (Math.random() - 0.5) * 6 + (distanceNorm - 0.5) * 3;
          
          positions.push({
            x: Math.max(margin, Math.min(100 - margin, baseLeft + leftOffset)),
            y: Math.max(margin, Math.min(100 - margin, baseTop + topOffset))
          });
        }
        
        // Normalize to ensure all sensors are visible and spread out
        let minX = Math.min(...positions.map(p => p.x));
        let maxX = Math.max(...positions.map(p => p.x));
        let minY = Math.min(...positions.map(p => p.y));
        let maxY = Math.max(...positions.map(p => p.y));
        
        // Ensure we have a range
        if (maxX === minX) { maxX = minX + 1; }
        if (maxY === minY) { maxY = minY + 1; }
        
        const rangeX = maxX - minX;
        const rangeY = maxY - minY;
        
        // Scale to fit with margin
        for (let i = 0; i < positions.length; i++) {
          const normalizedX = ((positions[i].x - minX) / rangeX) * (100 - 2 * margin) + margin;
          const normalizedY = ((positions[i].y - minY) / rangeY) * (100 - 2 * margin) + margin;
          
          sensors[i].left = normalizedX;
          sensors[i].top = normalizedY;
        }
      }
      
      calculatePositions();

      const buildingGrid = document.getElementById("buildingGrid");
      const statusSummary = document.getElementById("statusSummary");
      const relativeDistances = document.getElementById("relativeDistances");
      let currentSensors = sensors;
      let selectedSensorName = null;

      function renderSensors() {
        selectedSensorName = null;
        buildingGrid.innerHTML = "";
        
        // Calculate sensor size based on total count (more sensors = smaller dots)
        // Base size decreases as sensor count increases
        const baseSize = Math.max(8, 24 - (currentSensors.length * 0.2)); // Scales from 24px to 8px
        document.documentElement.style.setProperty('--esp-size', `${baseSize}px`);
        
        currentSensors.forEach((sensor) => {
          const point = document.createElement("div");
          point.className = "esp-point";
          point.style.top = `${sensor.top}%`;
          point.style.left = `${sensor.left}%`;
          point.dataset.status = sensor.status === "active" ? "active" : "inactive";
          point.dataset.sensorName = sensor.name;

          const tooltip = document.createElement("span");
          tooltip.className = "tooltip";
          tooltip.textContent = `${sensor.name} â€¢ ${sensor.status === "active" ? "Online" : "Offline"}`;
          point.appendChild(tooltip);

          const distance = document.createElement("span");
          distance.className = "distance-label";
          point.appendChild(distance);

          point.addEventListener("click", () => handleSensorClick(sensor.name));

          buildingGrid.appendChild(point);
        });
        updateDistanceLabels();
        updateRelativePanel();
        renderSummary();
      }

      function renderSummary() {
        const activeCount = currentSensors.filter((sensor) => sensor.status === "active").length;
        const inactiveCount = currentSensors.length - activeCount;

        statusSummary.innerHTML = `
          <div class="summary-card">
            <span>Active</span>
            <strong>${activeCount}</strong>
          </div>
          <div class="summary-card">
            <span>Offline</span>
            <strong>${inactiveCount}</strong>
          </div>
          <div class="summary-card">
            <span>Total Sensors</span>
            <strong>${currentSensors.length}</strong>
          </div>
          <div class="summary-card">
            <span>Total Distance</span>
            <strong>${sumDistances(currentSensors)}</strong>
          </div>
        `;
      }

      function sumDistances(sensors) {
        const total = sensors.reduce((sum, sensor) => {
          return Number.isFinite(sensor.distance) ? sum + sensor.distance : sum;
        }, 0);
        return `${total.toFixed(1)} m`;
      }

      function handleSensorClick(sensorName) {
        selectedSensorName = sensorName;
        document.querySelectorAll(".esp-point").forEach((point) => {
          point.classList.toggle("selected", point.dataset.sensorName === sensorName);
        });
        updateDistanceLabels();
        updateRelativePanel();
      }

      function updateDistanceLabels() {
        const selected = currentSensors.find((sensor) => sensor.name === selectedSensorName);
        document.querySelectorAll(".distance-label").forEach((label) => {
          label.classList.remove("visible");
          label.textContent = "";
        });
        if (!selected) return;

        currentSensors.forEach((sensor) => {
          const point = buildingGrid.querySelector(`.esp-point[data-sensor-name="${sensor.name}"]`);
          if (!point) return;
          const label = point.querySelector(".distance-label");
          if (!label) return;

          if (sensor.name === selected.name) {
            label.textContent = "0.0 m";
          } else {
            const relative = calculateRelativeDistance(selected, sensor);
            label.textContent = formatMeters(relative);
          }
          label.classList.add("visible");
        });
      }

      function calculateRelativeDistance(sensorA, sensorB) {
        // Use the average of both sensors' distance measurements as the relative distance
        // This represents the actual measured distance between sensors
        return (sensorA.distance + sensorB.distance) / 2;
      }

      function formatMeters(value) {
        return `${value.toFixed(1)} m`;
      }

      function updateRelativePanel() {
        relativeDistances.innerHTML = "";
        const selected = currentSensors.find((sensor) => sensor.name === selectedSensorName);

        if (!selected) {
          relativeDistances.innerHTML = '<div class="relative-placeholder">Select a sensor on the map to compare.</div>';
          return;
        }

        currentSensors
          .filter((sensor) => sensor.name !== selected.name)
          .map((sensor) => {
            const rawDistance = calculateRelativeDistance(selected, sensor);
            return {
              name: sensor.name,
              value: rawDistance,
              label: formatMeters(rawDistance),
            };
          })
          .sort((a, b) => a.value - b.value)
          .forEach((entry) => {
            const row = document.createElement("div");
            row.className = "relative-item";
            row.innerHTML = `<span>${entry.name}</span><strong>${entry.label}</strong>`;
            relativeDistances.appendChild(row);
          });
      }

      renderSensors();
    </script>
  </body>
</html>

